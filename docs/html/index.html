<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Spase Matrix: Sparse matrix</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Spase Matrix<span id="projectnumber">&#160;v0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Sparse matrix </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__2home_2ale_2sparse-matrix_2README"></a> </p>
<h1><a class="anchor" id="autotoc_md1"></a>
Matrix class</h1>
<h2><a class="anchor" id="autotoc_md2"></a>
Set up</h2>
<p>Clone the repository with the command: </p><div class="fragment"><div class="line">git clone --recurse-submodules git@github.com:martapignatelli/sparse-matrix.git</div>
</div><!-- fragment --><p> Be aware of the fact that <em>TBB</em> library is required to compile and execute the code.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Code structure</h2>
<div class="fragment"><div class="line">sparse-matrix</div>
<div class="line">├── LICENSE</div>
<div class="line">├── Makefile</div>
<div class="line">├── README.md</div>
<div class="line">├── data</div>
<div class="line">│   ├── complex_test_5x5.mtx</div>
<div class="line">│   ├── data.json</div>
<div class="line">│   ├── e20r0000.mtx</div>
<div class="line">│   ├── execution_time.json</div>
<div class="line">│   ├── lnsp_131.mtx</div>
<div class="line">│   └── real_test_5x5.mtx</div>
<div class="line">├── docs</div>
<div class="line">├── include</div>
<div class="line">│   ├── abstract_matrix.hpp</div>
<div class="line">│   ├── impl</div>
<div class="line">│   ├── json_utility.hpp</div>
<div class="line">│   ├── matrix.hpp</div>
<div class="line">│   ├── matrix_views.hpp</div>
<div class="line">│   ├── proxy.hpp</div>
<div class="line">│   ├── square_matrix.hpp</div>
<div class="line">│   ├── storage.hpp</div>
<div class="line">│   └── test.hpp</div>
<div class="line">├── json</div>
<div class="line">│   └── (...)</div>
<div class="line">└── src</div>
<div class="line">    └── main.cpp</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md4"></a>
Implementation</h2>
<p>We implemented all the methods requested and we built the following class-structure:</p><ul>
<li><b>AbstractMatrix</b>: base abstract template class that allows greater polymorphism among derived classes<ul>
<li><b>Matrix</b>: template class that encodes <b>COO Map</b> and <b>CSR/CSC</b> formats, as data structures for a matrix<ul>
<li><b>SquareMatrix</b>: template class specialized for square matrices, that encodes also the <b>MSR/MSC</b> format</li>
</ul>
</li>
<li>Views<ul>
<li><b>TransposeView</b></li>
<li><b>DiagonalView</b></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><b>Note</b>: in <code><a class="el" href="abstract__matrix_8hpp.html" title="Defines the AbstractMatrix interface for algebraic matrix operations.">abstract_matrix.hpp</a></code> you can see how we have conceptualized a matrix.</p>
<h3><a class="anchor" id="autotoc_md5"></a>
Design choises</h3>
<p>1) Data formats and associated components are defined in <code>Storage.hpp</code>. 2) We used concepts to require some specific properties (only the necessary ones) about the type of the elements of matrices, as illustrated by the following piece of code. <code>cpp template &lt;typename T&gt; concept AddMulType = requires(T a, T b) { { a + b } -&gt; std::convertible_to&lt;T&gt;; { a * b } -&gt; std::convertible_to&lt;T&gt;; { std::abs(a) } -&gt; std::convertible_to&lt;AbsReturnType_t&lt;T&gt;&gt;; }; </code> 3) For the dynamic storage techniques, among COO format and COOmap, we opted for the latter, since it provides access to random elements with $O(log(N))$ average complexity and it yields an easy and fast way to insert the elements in order. 4) <code>Proxy.hpp</code> was conceived to provide restricted access to private data, while still allowing operations such as: <code>cpp m(0, 0) = m(1, 1) + m(2, 2); </code> This approach ensures encapsulation while enabling controlled manipulation of matrix elements.</p>
<h3><a class="anchor" id="autotoc_md6"></a>
Products</h3>
<p>Below there are the declarations of all the matrix products we have implemented as friend functions of <em>Matrix</em> and <em>SquareMatrix</em> classes. </p><div class="fragment"><div class="line"><span class="comment">// Matrix products</span></div>
<div class="line"><span class="keyword">template</span> &lt;AddMulType U, StorageOrder V&gt;</div>
<div class="line">std::vector&lt;U&gt; operator*(<span class="keyword">const</span> Matrix&lt;U, V&gt; &amp;m, <span class="keyword">const</span> std::vector&lt;U&gt; &amp;v);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;AddMulType U, StorageOrder V&gt;</div>
<div class="line">Matrix&lt;U, V&gt; operator*(<span class="keyword">const</span> Matrix&lt;U, V&gt; &amp;m1, <span class="keyword">const</span> Matrix&lt;U, V&gt; &amp;m2);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// SquareMatrix products</span></div>
<div class="line"><span class="keyword">template</span> &lt;AddMulType U, StorageOrder V&gt;</div>
<div class="line">std::vector&lt;U&gt; operator*(<span class="keyword">const</span> SquareMatrix&lt;U, V&gt; &amp;m, <span class="keyword">const</span> std::vector&lt;U&gt; &amp;v);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;AddMulType U, StorageOrder V&gt;</div>
<div class="line">SquareMatrix&lt;U, V&gt; operator*(<span class="keyword">const</span> SquareMatrix&lt;U, V&gt; &amp;m1, <span class="keyword">const</span> SquareMatrix&lt;U, V&gt; &amp;m2);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// TransposeView products </span></div>
<div class="line"><span class="keyword">template</span> &lt;AddMulType U, StorageOrder V&gt;</div>
<div class="line">std::vector&lt;U&gt; operator*(<span class="keyword">const</span> TransposeView&lt;U, V&gt; &amp;m, <span class="keyword">const</span> std::vector&lt;U&gt; &amp;v);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;AddMulType U, StorageOrder V&gt;</div>
<div class="line">Matrix&lt;U, V&gt; operator*(<span class="keyword">const</span> TransposeView&lt;U, V&gt; &amp;m1, <span class="keyword">const</span> TransposeView&lt;U, V&gt; &amp;m2);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// DiagonalView products</span></div>
<div class="line"><span class="keyword">template</span> &lt;AddMulType U, StorageOrder V&gt;</div>
<div class="line">std::vector&lt;U&gt; operator*(<span class="keyword">const</span> DiagonalView&lt;U, V&gt; &amp;m, <span class="keyword">const</span> std::vector&lt;U&gt; &amp;v);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;AddMulType U, StorageOrder V&gt;</div>
<div class="line">SquareMatrix&lt;U, V&gt; operator*(<span class="keyword">const</span> DiagonalView&lt;U, V&gt; &amp;m1, <span class="keyword">const</span> DiagonalView&lt;U, V&gt; &amp;m2);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;AddMulType U, StorageOrder V&gt;</div>
<div class="line">Matrix&lt;U, V&gt; operator*(<span class="keyword">const</span> Matrix&lt;U, V&gt; &amp;m1, <span class="keyword">const</span> DiagonalView&lt;U, V&gt; &amp;m2);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;AddMulType U, StorageOrder V&gt;</div>
<div class="line">Matrix&lt;U, V&gt; operator*(<span class="keyword">const</span> DiagonalView&lt;U, V&gt; &amp;m1, <span class="keyword">const</span> Matrix&lt;U, V&gt; &amp;m2);</div>
</div><!-- fragment --> <h3><a class="anchor" id="autotoc_md7"></a>
Parallelization</h3>
<p>Many methods include <b>parallel execution policies</b>, to accelerate certain procedures, as maximum search or vector filling.\ We retained the method <code>compress_parallel()</code>, available only for the <em>Matrix</em> class, designed to perform the transition from the uncompressed format to the compressed format using a parallel approach with <code>std::atomic</code>. However, we did not further develop this idea because the overhead caused by creating an index vector is too significant, primarily due to the use of the <code>std::iota</code> function.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Test</h2>
<p>The code has been tested in two different ways, always starting from matrices in <em>Matrix Market format</em>.</p>
<p>1) Initially, with matrices of size $(5 \times 5)$:</p><ul>
<li><code>real_test_5x5.mtx</code>, containing real entries</li>
<li><code>complex_test_5x5.mtx</code>, containing complex entries <br  />
</li>
</ul>
<p>These matrices allow for an easy visualization of the results in the terminal.</p>
<p>2) Subsequently, with larger matrices:</p><ul>
<li><a href="https://math.nist.gov/MatrixMarket/data/Harwell-Boeing/lns/lnsp_131.html"><code>lnsp_131.mtx</code></a> $(131 \times 131)$</li>
<li><a href="https://math.nist.gov/MatrixMarket/data/SPARSKIT/drivcav/e20r0000.html"><code>e20r0000.mtx</code></a> $(1182 \times 1182)$</li>
</ul>
<p>These matrices, in particular, can be selected using the dedicated file <code>data/data.json</code>, which contains a list of the names of the matrices that will be tested by the code. To test different matrices, it will be sufficient to modify this list with the desired names after optionally adding the desired matrix to the <code>data</code> folder.</p>
<p><b>Important</b>: the aforementioned information could be useful in scenarios where one wishes to avoid testing the second matrix, which has significantly larger dimensions and might require more execution time for the code.</p>
<p>The tests that have been performed are as follows:</p><ul>
<li>validation of the <b>compression</b> operation, corresponding to the methods <code>compress()</code>, <code>uncompress()</code>, and <code>compress_mod()</code> (the latter available only for the <em>SquareMatrix</em> class)</li>
<li>calculation of the three types of <b>norms</b>, using the method <code>norm&lt;N&gt;()</code>, where $N$ is the type of the norm (One, Infinity, Frobenius)</li>
<li>execution time of the <b>matrix-vector product</b>, where the vector was randomly generated</li>
<li>execution time of the <b>matrix-matrix product</b>, leveraging the fact that the tested matrices are square</li>
</ul>
<p><b>Speedup</b>: the execution times of the products are taken (exploiting <code>std::chrono</code>) for the matrix in both compressed and uncompressed formats and they are saved in <code>execution_time.json</code>, allowing them to be displayed on the screen along with the corresponding speedups, calculated as $$\text{speedup} = \frac{\text{execution time in uncompressed format}}{\text{execution time in compressed format}},$$ so that we can appreciate the improvements in terms of speed achieved thanks to the compressed format. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
